#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#define BUFFER_SIZE 1048576
#define NAME_SIZE 1024
const char key[]={
0x77,0x48,0x32,0x73,0xDE,0xF2,0xC0,0xC8,0x95,0xEC,0x30,0xB2,0x51,0xC3,0xE1,0xA0,
0x9E,0xE6,0x9D,0xCF,0xFA,0x7F,0x14,0xD1,0xCE,0xB8,0xDC,0xC3,0x4A,0x67,0x93,0xD6,
0x28,0xC2,0x91,0x70,0xCA,0x8D,0xA2,0xA4,0xF0,0x08,0x61,0x90,0x7E,0x6F,0xA2,0xE0,
0xEB,0xAE,0x3E,0xB6,0x67,0xC7,0x92,0xF4,0x91,0xB5,0xF6,0x6C,0x5E,0x84,0x40,0xF7,
0xF3,0x1B,0x02,0x7F,0xD5,0xAB,0x41,0x89,0x28,0xF4,0x25,0xCC,0x52,0x11,0xAD,0x43,
0x68,0xA6,0x41,0x8B,0x84,0xB5,0xFF,0x2C,0x92,0x4A,0x26,0xD8,0x47,0x6A,0x7C,0x95,
0x61,0xCC,0xE6,0xCB,0xBB,0x3F,0x47,0x58,0x89,0x75,0xC3,0x75,0xA1,0xD9,0xAF,0xCC,
0x08,0x73,0x17,0xDC,0xAA,0x9A,0xA2,0x16,0x41,0xD8,0xA2,0x06,0xC6,0x8B,0xFC,0x66,
0x34,0x9F,0xCF,0x18,0x23,0xA0,0x0A,0x74,0xE7,0x2B,0x27,0x70,0x92,0xE9,0xAF,0x37,
0xE6,0x8C,0xA7,0xBC,0x62,0x65,0x9C,0xC2,0x08,0xC9,0x88,0xB3,0xF3,0x43,0xAC,0x74,
0x2C,0x0F,0xD4,0xAF,0xA1,0xC3,0x01,0x64,0x95,0x4E,0x48,0x9F,0xF4,0x35,0x78,0x95,
0x7A,0x39,0xD6,0x6A,0xA0,0x6D,0x40,0xE8,0x4F,0xA8,0xEF,0x11,0x1D,0xF3,0x1B,0x3F,
0x3F,0x07,0xDD,0x6F,0x5B,0x19,0x30,0x19,0xFB,0xEF,0x0E,0x37,0xF0,0x0E,0xCD,0x16,
0x49,0xFE,0x53,0x47,0x13,0x1A,0xBD,0xA4,0xF1,0x40,0x19,0x60,0x0E,0xED,0x68,0x09,
0x06,0x5F,0x4D,0xCF,0x3D,0x1A,0xFE,0x20,0x77,0xE4,0xD9,0xDA,0xF9,0xA4,0x2B,0x76,
0x1C,0x71,0xDB,0x00,0xBC,0xFD,0x0C,0x6C,0xA5,0x47,0xF7,0xF6,0x00,0x79,0x4A,0x11
};
const char mp3Head[]={0x49,0x44,0x33,0x03,0x00};
const char flacHead[]={0x66,0x4C,0x61,0x43,0x00};
const char oggHead[]={0x4F,0x67,0x67,0x53,0x00};
const char m4aHead[]={0x00,0x00,0x00,0x18,0x00};
char buffer[BUFFER_SIZE];

char getKey(size_t i)
{
	if (i>=0)
  	{
		if(i>0x7FFF)
			i%=0x7FFF;
	}else i=0;
	return key[(i*i+80923)%256];
}

int main(int argc,char **argv)
{
	int fileCount;
	size_t i;
	char name[NAME_SIZE];
	for(fileCount=1;fileCount<argc;fileCount++){
		strcpy(name,argv[fileCount]);
		FILE *input=fopen(name,"rb");
		if(!input){
			printf("error: cannot open %s\n",name);
			continue;
		}else printf("%s --> ",name);
		
		size_t count,front=0;
		
		//read head and rename
		bool flag=1;
		for(i=strlen(name)-1;;i--)
			if (i<=0)
				break;
			else if(name[i]=='['){
				if(i>=1&&name[i-1]==' '){
					name[i-1]='\0';
					break;
				}
			}else if(name[i]=='.')
				if(flag){
					name[i]='\0';
					flag=0;
				}
		fread(buffer,4,1,input);
		for(i=0;i<4;i++)
			buffer[i]^=getKey(front+i);
		buffer[4]='\0';
		if(strcmp(buffer,mp3Head)==0)
			strcat(name,".mp3");
		else if(strcmp(buffer,flacHead)==0)
			strcat(name,".flac");
		else if(strcmp(buffer,oggHead)==0)
			strcat(name,".ogg");
		else if(strcmp(buffer,m4aHead)==0)
			strcat(name,".m4a");
		else{
			printf("error: cannot decrypt\n");
			continue;
		}
		front+=4;
		
		FILE *output=fopen(name,"wb");
		if(!output){
			printf("error: cannot write %s\n",name);
			continue;
		}else printf("%s\n",name);
		
		fwrite(buffer,4,1,output);
		
		//decrypt
		while(count=fread(buffer,1,BUFFER_SIZE,input),count!=0){
			for(i=0;i<count;i++)
				buffer[i]^=getKey(front+i);
			fwrite(buffer,count,1,output);
			front+=count;
		}
	}
	return 0;
}
